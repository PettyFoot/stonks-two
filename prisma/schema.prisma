generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                    String               @id @default(cuid())
  email                 String               @unique
  auth0Id               String               @unique
  name                  String?
  isAdmin               Boolean              @default(false)
  createdAt             DateTime             @default(now())
  updatedAt             DateTime             @updatedAt
  lastLoginAt           DateTime?
  stripeCustomerId      String?              @unique
  subscriptionStatus    SubscriptionStatus   @default(INACTIVE)
  subscriptionTier      SubscriptionTier     @default(FREE)
  canReactivate         Boolean              @default(true)
  deletedAt             DateTime?
  deletionReason        String?
  deletionRequestedAt   DateTime?
  finalDeletionAt       DateTime?
  anonymizedAt          DateTime?
  snapTradeRegisteredAt DateTime?
  snapTradeUserId       String?              @unique
  snapTradeUserSecret   String?
  autoSyncEnabled       Boolean              @default(true)
  accountDeletionLogs   AccountDeletionLog[]
  apiUsage              ApiUsage[]
  csvUploadLogs         CsvUploadLog[]
  importBatches         ImportBatch[]
  orders                Order[]
  paymentHistory        PaymentHistory[]
  recordsEntries        RecordsEntry[]
  sharedTrades          SharedTrade[]
  snapTradeSyncs        SnapTradeSync[]
  subscriptions         Subscription[]
  syncRateLimits        SyncRateLimit[]
  trades                Trade[]
  aiIngestChecks        AiIngestToCheck[] @relation("UserAiIngestChecks")
  adminReviews          AiIngestToCheck[] @relation("AdminReviews")
  dailyUploadCounts     DailyUploadCount[]
  userPreferences       UserPreferences?
  approvedFormats       BrokerCsvFormat[] @relation("ApprovedFormats")
  orderStaging          OrderStaging[]
  pageViews             PageView[]
  importPageInteractions ImportPageInteraction[]
  feedbackResponses     FeedbackResponse[]
  blogPosts             BlogPost[]

  @@index([email, createdAt])
  @@index([subscriptionTier, subscriptionStatus])
  @@index([isAdmin, deletedAt])
  @@map("users")
}

model UserPreferences {
  id                    String   @id @default(cuid())
  userId                String   @unique
  billingAddress        Json?
  taxId                 String?
  businessName          String?
  emailInvoices         Boolean  @default(true)
  sendBillingReminders  Boolean  @default(false)
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_preferences")
}

model Trade {
  id                String        @id @default(cuid())
  userId            String
  symbol            String
  assetClass        AssetClass    @default(EQUITY)
  brokerName        String?
  tradeSource       TradeSource   @default(IMPORTED)
  orderType         OrderType     @default(MARKET)
  side              TradeSide
  timeInForce       TimeInForce   @default(DAY)
  remainingQuantity Int?
  averageFillPrice  Decimal?      @db.Decimal(10, 2)
  status            TradeStatus   @default(OPEN)
  avgEntryPrice     Decimal?
  avgExitPrice      Decimal?
  openQuantity      Int?
  closeQuantity     Int?
  entryDate         DateTime
  exitDate          DateTime?
  timeInTrade       Int?
  marketSession     MarketSession @default(REGULAR)
  holdingPeriod     HoldingPeriod @default(INTRADAY)
  entryPrice        Decimal?      @db.Decimal(10, 2)
  exitPrice         Decimal?      @db.Decimal(10, 2)
  highDuringTrade   Decimal?      @db.Decimal(10, 2)
  lowDuringTrade    Decimal?      @db.Decimal(10, 2)
  openTime          DateTime?
  closeTime         DateTime?
  quantity          Int?
  costBasis         Decimal?      @db.Decimal(10, 2)
  proceeds          Decimal?      @db.Decimal(10, 2)
  ordersInTrade     String[]
  ordersCount       Int?
  isCalculated      Boolean       @default(false)
  date              DateTime
  executions        Int           @default(1)
  pnl               Decimal       @default(0) @db.Decimal(10, 2)
  commission        Decimal?      @db.Decimal(10, 2)
  fees              Decimal?      @db.Decimal(10, 2)
  notes             String?
  tags              String[]
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  importBatchId     String?
  notesChanges      String?
  recordsEntryId    String?
  importSource      ImportSource  @default(CSV)
  snapTradeId       String?
  importBatch       ImportBatch?  @relation(fields: [importBatchId], references: [id])
  recordsEntry      RecordsEntry? @relation(fields: [recordsEntryId], references: [id])
  user              User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, date])
  @@index([userId, symbol])
  @@index([userId, assetClass])
  @@index([userId, side])
  @@index([userId, symbol, status])
  @@index([userId, entryPrice])
  @@index([userId, exitPrice])
  @@index([userId, quantity])
  @@index([userId, executions])
  @@index([userId, commission])
  @@index([userId, fees])
  @@index([userId, entryDate])
  @@index([userId, exitDate])
  @@index([userId, status, date])
  @@index([userId, date, status])
  @@index([userId, pnl])
  @@index([userId, createdAt])
  @@index([userId, symbol, date])
  @@map("trades")
}

model Order {
  id                  String        @id @default(cuid())
  userId              String
  orderId             String
  parentOrderId       String?
  splitFromOrderId    String?       // Tracks the original order ID when this order was created from a split
  symbol              String
  orderType           OrderType
  side                OrderSide
  timeInForce         TimeInForce
  orderQuantity       Int
  limitPrice          Decimal?      @db.Decimal(10, 2)
  stopPrice           Decimal?      @db.Decimal(10, 2)
  orderStatus         OrderStatus
  orderPlacedTime     DateTime
  orderExecutedTime   DateTime?
  orderUpdatedTime    DateTime?
  orderCancelledTime  DateTime?
  accountId           String?
  orderAccount        String?
  orderRoute          String?
  brokerType          BrokerType    @default(GENERIC_CSV)
  commission          Decimal?      @db.Decimal(10, 2)
  fees                Decimal?      @db.Decimal(10, 2)
  tags                String[]
  usedInTrade         Boolean       @default(false)
  tradeId             String?
  importBatchId       String?
  activityHash        String?
  brokerMetadata      Json?
  datePrecision       DatePrecision @default(MILLISECOND)
  importSequence      Int?
  snapTradeActivityId String?       @unique
  importBatch         ImportBatch?  @relation(fields: [importBatchId], references: [id])
  user                User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  stagingRecords      OrderStaging[] @relation("StagingToOrder")

  @@unique([orderId, brokerType])
  @@index([userId, symbol])
  @@index([userId, orderStatus])
  @@index([tradeId])
  @@index([userId, tradeId])
  @@index([userId, snapTradeActivityId])
  @@index([userId, activityHash])
  @@index([userId, brokerType, orderExecutedTime])
  @@index([userId, orderPlacedTime])
  @@index([userId, orderStatus, orderPlacedTime])
  @@index([splitFromOrderId])
  @@map("orders")
}

model SplitOrdersParentOrders {
  id                  String        @id @default(cuid())
  userId              String
  orderId             String
  parentOrderId       String?
  splitFromOrderId    String?
  symbol              String
  orderType           OrderType
  side                OrderSide
  timeInForce         TimeInForce
  orderQuantity       Int
  limitPrice          Decimal?      @db.Decimal(10, 2)
  stopPrice           Decimal?      @db.Decimal(10, 2)
  orderStatus         OrderStatus
  orderPlacedTime     DateTime
  orderExecutedTime   DateTime?
  orderUpdatedTime    DateTime?
  orderCancelledTime  DateTime?
  accountId           String?
  orderAccount        String?
  orderRoute          String?
  brokerType          BrokerType    @default(GENERIC_CSV)
  commission          Decimal?      @db.Decimal(10, 2)
  fees                Decimal?      @db.Decimal(10, 2)
  tags                String[]
  usedInTrade         Boolean       @default(false)
  tradeId             String?
  importBatchId       String?
  activityHash        String?
  brokerMetadata      Json?
  datePrecision       DatePrecision @default(MILLISECOND)
  importSequence      Int?
  snapTradeActivityId String?
  archivedAt          DateTime      @default(now())

  @@index([userId, symbol])
  @@index([orderId, brokerType])
  @@index([userId, archivedAt])
  @@map("split_orders_parent_orders")
}

model RecordsEntry {
  id          String   @id @default(cuid())
  userId      String
  date        DateTime
  pnl         Float
  totalTrades Int
  totalVolume Int
  winRate     Float?
  mfeRatio    Float?
  netPnl      Float?
  commissions Float?
  notes       String?
  chartImage  String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  trades      Trade[]

  @@index([userId, date])
  @@map("records_entries")
}

model ImportBatch {
  id                  String         @id @default(cuid())
  userId              String
  filename            String
  fileSize            Int?
  brokerType          BrokerType
  importType          ImportType     @default(STANDARD)
  status              ImportStatus
  totalRecords        Int            @default(0)
  successCount        Int            @default(0)
  errorCount          Int            @default(0)
  errors              Json?
  aiMappingUsed       Boolean        @default(false)
  mappingConfidence   Float?
  columnMappings      Json?
  userReviewRequired  Boolean        @default(false)
  jobId               String?
  processingStarted   DateTime?
  processingCompleted DateTime?
  createdAt           DateTime       @default(now())
  updatedAt           DateTime       @updatedAt
  tempFileContent     String?

  // Upload Session Management Fields
  uploadSessionId      String?       // Groups related upload attempts (hash of filename+userId)
  expectedRowCount     Int?          // Total rows expected in current file version
  completedRowCount    Int           @default(0) // Successfully uploaded unique rows (not duplicates)
  isSessionComplete    Boolean       @default(false) // All expected rows uploaded
  holdTradeCalculation Boolean       @default(false) // Don't calculate trades until complete
  sessionAttempts      Int           @default(1) // Track retry count for this session
  sessionStatus        String        @default("ACTIVE") // ACTIVE, SUPERSEDED, COMPLETED, EXPIRED

  csvUploadLogs       CsvUploadLog[]
  user                User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  orders              Order[]
  trades              Trade[]
  aiIngestCheck       AiIngestToCheck?
  orderStaging        OrderStaging[]

  @@index([userId, status])
  @@index([userId, importType])
  @@index([uploadSessionId, sessionStatus])
  @@index([userId, uploadSessionId])
  @@map("import_batches")
}

model CsvUploadLog {
  id              String       @id @default(cuid())
  userId          String
  importBatchId   String?
  filename        String
  originalHeaders String[]
  mappedHeaders   Json?
  rowCount        Int
  uploadStatus    UploadStatus
  errorMessage    String?
  parseMethod     ParseMethod
  aiConfidence    Float?
  userInteraction Boolean      @default(false)
  createdAt       DateTime     @default(now())
  importBatch     ImportBatch? @relation(fields: [importBatchId], references: [id])
  user            User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  aiIngestCheck   AiIngestToCheck?

  @@index([userId, createdAt])
  @@map("csv_upload_logs")
}

model Subscription {
  id                   String             @id @default(cuid())
  userId               String
  stripeSubscriptionId String             @unique
  stripeCustomerId     String
  stripePriceId        String
  tier                 SubscriptionTier
  status               SubscriptionStatus
  currentPeriodStart   DateTime
  currentPeriodEnd     DateTime
  cancelAtPeriodEnd    Boolean            @default(false)
  canceledAt           DateTime?
  trialStart           DateTime?
  trialEnd             DateTime?
  createdAt            DateTime           @default(now())
  updatedAt            DateTime           @updatedAt
  user                 User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([stripeSubscriptionId])
  @@index([status])
  @@map("subscriptions")
}

model PaymentHistory {
  id                    String        @id @default(cuid())
  userId                String
  stripePaymentIntentId String        @unique
  stripeSubscriptionId  String?
  amount                Int
  currency              String        @default("usd")
  status                PaymentStatus
  description           String?
  receiptUrl            String?
  createdAt             DateTime      @default(now())
  updatedAt             DateTime      @updatedAt
  user                  User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([stripePaymentIntentId])
  @@index([status])
  @@map("payment_history")
}

model WebhookEvent {
  id            String    @id @default(cuid())
  stripeEventId String    @unique
  eventType     String
  processed     Boolean   @default(false)
  processedAt   DateTime?
  data          Json
  createdAt     DateTime  @default(now())

  @@index([stripeEventId])
  @@index([eventType])
  @@index([processed])
  @@map("webhook_events")
}

model AccountDeletionLog {
  id           String         @id @default(cuid())
  userId       String
  userEmail    String
  action       DeletionAction
  performedBy  String
  reason       String?
  details      Json?
  scheduledFor DateTime?
  completedAt  DateTime?
  createdAt    DateTime       @default(now())
  user         User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([action])
  @@index([createdAt])
  @@map("account_deletion_logs")
}

model SharedTrade {
  id                  String    @id @default(cuid())
  shareKey            String    @unique
  userId              String
  tradeSnapshot       Json
  orderSnapshot       Json
  metadata            Json?
  expiresAt           DateTime
  accessCount         Int       @default(0)
  apiCallCount        Int       @default(0)
  maxApiCalls         Int       @default(200)
  lastApiCallAt       DateTime?
  apiCallsPerMinute   Int       @default(0)
  minuteWindowStart   DateTime?
  createdAt           DateTime  @default(now())
  user                User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([shareKey])
  @@index([userId, expiresAt])
  @@index([expiresAt])
  @@index([apiCallCount, maxApiCalls])
  @@map("shared_trades")
}

model SharedTradeDeletion {
  id               String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  shareKey         String
  userId           String
  deletedAt        DateTime @default(now())
  deletionReason   String
  finalApiCount    Int?
  accessCount      Int?
  createdAt        DateTime @default(now())

  @@index([userId])
  @@index([deletedAt])
  @@index([shareKey])
  @@map("shared_trade_deletions")
}

model SnapTradeSyncConfig {
  id            String   @id @default(cuid())
  startDate     String   @default("2015-01-01") // YYYY-MM-DD format
  endDate       String?  // If null, uses current date
  limit         Int      @default(500)
  activityTypes String   @default("BUY,SELL") // Comma-separated list
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@map("snaptrade_sync_config")
}

model SnapTradeSync {
  id              String     @id @default(cuid())
  userId          String
  connectionId    String
  syncType        SyncType   @default(MANUAL)
  status          SyncStatus @default(PENDING)
  startedAt       DateTime   @default(now())
  completedAt     DateTime?
  activitiesFound Int        @default(0)
  ordersCreated   Int        @default(0)
  orderIds        Json?      // Array of order IDs created during this sync
  dataReturned    Boolean    @default(false) // Whether any data was returned from API
  dateRange       Json?      // Start and end dates used for this sync
  errors          Json?
  user            User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, connectionId])
  @@index([userId, startedAt])
  @@index([status])
  @@index([dataReturned])
  @@map("snaptrade_syncs")
}

model Broker {
  id         String            @id @default(cuid())
  name       String            @unique
  website    String?
  createdAt  DateTime          @default(now())
  updatedAt  DateTime          @updatedAt
  aliases    BrokerAlias[]
  csvFormats BrokerCsvFormat[]

  @@index([name])
  @@map("brokers")
}

model BrokerAlias {
  id       String @id @default(cuid())
  brokerId String
  alias    String @unique
  broker   Broker @relation(fields: [brokerId], references: [id], onDelete: Cascade)

  @@index([alias])
  @@index([brokerId])
  @@map("broker_aliases")
}

model BrokerCsvFormat {
  id                String    @id @default(cuid())
  brokerId          String
  formatName        String
  description       String?
  headerFingerprint String
  headers           String[]
  sampleData        Json?
  fieldMappings     Json
  confidence        Float
  usageCount        Int       @default(0)
  lastUsed          DateTime?
  successRate       Float     @default(1.0)
  createdBy         String?
  isApproved        Boolean   @default(false)
  approvedBy        String?
  approvedAt        DateTime?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  broker            Broker    @relation(fields: [brokerId], references: [id], onDelete: Cascade)
  approvedByUser    User?     @relation("ApprovedFormats", fields: [approvedBy], references: [id])
  aiIngestChecks    AiIngestToCheck[]
  orderStaging      OrderStaging[]

  @@unique([brokerId, headerFingerprint])
  @@index([headerFingerprint])
  @@index([brokerId])
  @@index([brokerId, usageCount])
  @@index([isApproved])
  @@map("broker_csv_formats")
}

model SyncRateLimit {
  id              String    @id @default(cuid())
  userId          String
  date            DateTime  @db.Date
  manualSyncCount Int       @default(0)
  lastSyncAt      DateTime?
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, date])
  @@index([userId, date])
  @@map("sync_rate_limits")
}

model ApiUsage {
  id                 String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId             String   @map("user_id")
  apiProvider        String   @default("polygon") @map("api_provider") @db.VarChar(50)
  endpoint           String   @db.VarChar(255)
  method             String   @default("GET") @db.VarChar(10)
  requestParams      Json?    @map("request_params")
  responseStatusCode Int?     @map("response_status_code")
  responseTimeMs     Int?     @map("response_time_ms")
  responseSizeBytes  Int?     @map("response_size_bytes")
  timestamp          DateTime @default(now()) @db.Timestamptz(6)
  countedForLimit    Boolean  @default(true) @map("counted_for_limit")
  subscriptionTier   String?  @map("subscription_tier") @db.VarChar(50)
  errorMessage       String?  @map("error_message")
  apiCreditsUsed     Int      @default(1) @map("api_credits_used")
  createdAt          DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  isError            Boolean? @default(dbgenerated("(response_status_code >= 400)")) @map("is_error")
  user               User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, timestamp(sort: Desc)], map: "idx_api_usage_rate_limit")
  @@index([userId, timestamp(sort: Desc), apiProvider, countedForLimit], map: "idx_api_usage_user_window")
  @@index([userId, endpoint, timestamp(sort: Desc)], map: "idx_api_usage_endpoint_analytics")
  @@index([userId, timestamp(sort: Desc)], map: "idx_api_usage_errors")
  @@index([apiProvider, userId, timestamp(sort: Desc)], map: "idx_api_usage_provider")
  @@index([timestamp(sort: Desc)], map: "idx_api_usage_cleanup")
  @@index([createdAt(sort: Desc)], map: "idx_api_usage_created_cleanup")
  @@map("api_usage")
}

model AiIngestToCheck {
  id                 String            @id @default(cuid())
  userId             String
  brokerCsvFormatId  String?
  csvUploadLogId     String            @unique
  importBatchId      String            @unique
  processingStatus   ProcessingStatus  @default(PENDING)
  orderIds           String[]          @default([])
  processedAt        DateTime?
  processingError    String?
  processingTimeMs   Int?
  userIndicatedError Boolean           @default(false)
  userReviewedAt     DateTime?
  adminReviewStatus  AdminReviewStatus @default(PENDING)
  adminNotes         String?
  adminReviewedAt    DateTime?
  adminReviewedBy    String?
  denialReason       String?
  denialMessage      String?
  deniedAt           DateTime?
  aiConfidence       Float             @db.Real
  mappingAccuracy    Float?            @db.Real
  dataQualityScore   Float?            @db.Real
  createdAt          DateTime          @default(now())
  updatedAt          DateTime          @updatedAt

  // Relations
  user              User              @relation("UserAiIngestChecks", fields: [userId], references: [id], onDelete: Cascade)
  brokerCsvFormat   BrokerCsvFormat?  @relation(fields: [brokerCsvFormatId], references: [id], onDelete: SetNull)
  csvUploadLog      CsvUploadLog      @relation(fields: [csvUploadLogId], references: [id])
  importBatch       ImportBatch       @relation(fields: [importBatchId], references: [id])
  adminReviewer     User?             @relation("AdminReviews", fields: [adminReviewedBy], references: [id])
  feedbackItems     AiIngestFeedbackItem[]

  @@index([adminReviewStatus, createdAt], map: "idx_ai_ingest_checks_admin_queue")
  @@index([brokerCsvFormatId], map: "idx_ai_ingest_checks_broker_format")
  @@index([aiConfidence], map: "idx_ai_ingest_checks_confidence")
  @@index([userIndicatedError, adminReviewStatus], map: "idx_ai_ingest_checks_priority")
  @@index([userId, userIndicatedError, createdAt(sort: Desc)], map: "idx_ai_ingest_checks_user_flagged")
  @@index([userId, createdAt(sort: Desc)], map: "idx_ai_ingest_checks_user_recent")
  @@map("ai_ingest_checks")
}

model AiIngestFeedbackItem {
  id               String    @id @default(cuid())
  aiIngestCheckId  String
  csvHeader        String    @db.VarChar(255)
  aiMapping        String    @db.VarChar(255)
  suggestedMapping String?   @db.VarChar(255)
  issueType        String?
  comment          String?
  confidence       Float?    @db.Real
  isCorrect        Boolean?
  correctedBy      String?
  correctedAt      DateTime?
  originalValue    String?
  createdAt        DateTime  @default(now())
  aiIngestCheck    AiIngestToCheck @relation(fields: [aiIngestCheckId], references: [id], onDelete: Cascade)

  @@index([aiIngestCheckId], map: "idx_ai_ingest_feedback_items_check")
  @@map("ai_ingest_feedback_items")
}

model DailyUploadCount {
  id     String   @id @default(dbgenerated("(gen_random_uuid())::text"))
  userId String
  date   DateTime @db.Date
  count  Int?     @default(0)
  user   User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, date], map: "unique_user_date")
  @@index([userId, date], map: "idx_daily_upload_counts")
  @@map("daily_upload_counts")
}

model OrderStaging {
  id                String           @id @default(cuid())
  userId            String
  importBatchId     String
  brokerCsvFormatId String

  // Raw data storage (JSON for compatibility)
  rawCsvRow         Json
  rowIndex          Int
  initialMappedData Json?
  processingErrors  String[]         @default([])

  // Migration tracking
  migrationStatus   MigrationStatus  @default(PENDING)
  approvedBy        String?
  approvedAt        DateTime?
  migratedAt        DateTime?
  orderId           String?          // Link to created Order after migration

  // Performance metrics
  processingDurationMs Int?
  retryCount          Int           @default(0)
  lastRetryAt         DateTime?

  // Timestamps
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  retentionDate     DateTime         @default(dbgenerated("NOW() + INTERVAL '30 days'"))

  // Relations
  user              User             @relation(fields: [userId], references: [id])
  importBatch       ImportBatch      @relation(fields: [importBatchId], references: [id])
  brokerCsvFormat   BrokerCsvFormat  @relation(fields: [brokerCsvFormatId], references: [id])
  order             Order?           @relation("StagingToOrder", fields: [orderId], references: [id])

  // Optimized indexes
  @@unique([importBatchId, rowIndex])
  @@index([userId, migrationStatus, createdAt])
  @@index([brokerCsvFormatId, migrationStatus])
  @@index([migrationStatus, createdAt])
  @@index([createdAt, migrationStatus])
  @@index([retentionDate])
  @@map("order_staging")
}

model StagingAuditLog {
  id              String   @id @default(cuid())
  stagingId       String
  action          String
  performedBy     String
  previousState   Json
  newState        Json
  timestamp       DateTime @default(now())

  @@index([stagingId, timestamp])
  @@map("staging_audit_logs")
}

enum MigrationStatus {
  PENDING
  APPROVED
  MIGRATING
  MIGRATED
  FAILED
  REJECTED

  @@map("migration_status")
}

enum SubscriptionTier {
  FREE
  PREMIUM

  @@map("subscription_tier")
}

enum SubscriptionStatus {
  INACTIVE
  ACTIVE
  PAST_DUE
  CANCELED
  UNPAID
  TRIALING

  @@map("subscription_status")
}

enum PaymentStatus {
  SUCCEEDED
  PENDING
  FAILED
  CANCELED
  REFUNDED

  @@map("payment_status")
}

enum AssetClass {
  EQUITY
  FUTURES
  OPTIONS
  FOREX
  CRYPTO
  BOND
  ETF
  MUTUAL_FUND
  COMMODITY

  @@map("asset_class")
}

enum TradeSide {
  LONG
  SHORT

  @@map("trade_side")
}

enum TradeStatus {
  OPEN
  CLOSED
  BLANK

  @@map("trade_status")
}

enum OrderSide {
  BUY
  SELL

  @@map("order_side")
}

enum TradeSource {
  MANUAL
  ALGORITHMIC
  API
  IMPORTED
  COPY_TRADING

  @@map("trade_source")
}

enum OrderType {
  MARKET
  LIMIT
  STOP
  STOP_LIMIT
  TRAILING_STOP
  MARKET_ON_CLOSE
  LIMIT_ON_CLOSE
  PEGGED_TO_MIDPOINT

  @@map("order_type")
}

enum TimeInForce {
  DAY
  GTC
  IOC
  FOK
  GTD

  @@map("time_in_force")
}


enum MarketSession {
  PRE_MARKET
  REGULAR
  AFTER_HOURS
  EXTENDED

  @@map("market_session")
}

enum HoldingPeriod {
  SCALP
  INTRADAY
  SWING
  POSITION
  LONG_TERM

  @@map("holding_period")
}

enum OrderStatus {
  PENDING
  PARTIALLY_FILLED
  FILLED
  CANCELLED
  REJECTED
  EXPIRED

  @@map("order_status")
}

enum BrokerType {
  INTERACTIVE_BROKERS
  TD_AMERITRADE
  E_TRADE
  CHARLES_SCHWAB
  FIDELITY
  ROBINHOOD
  ALPACA
  BINANCE
  CHASE
  COINBASE
  DEGIRO
  KRAKEN
  PUBLIC
  QUESTRADE
  STAKE
  TASTYTRADE
  TRADIER
  TRADING212
  VANGUARD
  WEALTHSIMPLE
  WEBULL
  ZERODHA
  AJ_BELL
  GENERIC_CSV

  @@map("broker_type")
}

enum ImportStatus {
  PENDING
  PROCESSING
  COMPLETED
  PARTIAL
  FAILED

  @@map("import_status")
}

enum ImportType {
  STANDARD
  CUSTOM

  @@map("import_type")
}

enum UploadStatus {
  UPLOADED
  PARSING
  MAPPED
  VALIDATED
  IMPORTED
  FAILED

  @@map("upload_status")
}

enum ParseMethod {
  STANDARD
  AI_MAPPED
  USER_CORRECTED

  @@map("parse_method")
}

enum DeletionAction {
  REQUESTED
  REACTIVATED
  SOFT_DELETED
  HARD_DELETED
  EXPIRED

  @@map("deletion_action")
}

enum ImportSource {
  CSV
  SNAPTRADE_API
  MANUAL

  @@map("import_source")
}

enum DatePrecision {
  DAILY
  MILLISECOND

  @@map("date_precision")
}

enum SyncType {
  MANUAL
  AUTOMATIC
  WEBHOOK

  @@map("sync_type")
}

enum SyncStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED

  @@map("sync_status")
}

enum ProcessingStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  REJECTED
  RETRY_NEEDED

  @@map("processing_status")
}

enum AdminReviewStatus {
  PENDING
  IN_REVIEW
  APPROVED
  CORRECTED
  DISMISSED
  DENIED
  ESCALATED

  @@map("admin_review_status")
}

model PageView {
  id          String    @id @default(cuid())
  userId      String
  path        String    // Normalized route path, e.g., "/dashboard", "/settings"
  duration    Int?      // Time spent on page in milliseconds
  enteredAt   DateTime  @default(now())
  exitedAt    DateTime?
  sessionId   String    // Browser session identifier
  createdAt   DateTime  @default(now())

  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, enteredAt])
  @@index([userId, path])
  @@index([sessionId])
  @@index([createdAt])
  @@map("page_views")
}

model ImportPageInteraction {
  id              String   @id @default(cuid())
  userId          String
  sessionId       String   // Browser session identifier
  action          String   // e.g., "file_selected", "upload_started", "broker_connected"
  component       String   // e.g., "EnhancedFileUpload", "BrokerList", "SnapTradeConnector"
  outcome         String?  // "success", "failure", "cancelled"
  errorMessage    String?  // Error message if outcome is failure
  metadata        Json?    // Flexible JSON for additional context (file size, broker name, etc.)
  importBatchId   String?  // Link to import batch if applicable
  timestamp       DateTime @default(now())
  createdAt       DateTime @default(now())

  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, timestamp])
  @@index([action, timestamp])
  @@index([sessionId])
  @@index([importBatchId])
  @@map("import_page_interactions")
}

// ============================================================================
// ANALYTICS MODELS - Track all visitors (authenticated + non-authenticated)
// ============================================================================

model AnalyticsSession {
  id              String    @id @default(cuid())
  sessionId       String    @unique // Client-generated session ID
  userId          String?   // NULL for anonymous visitors

  // UTM Parameters from landing
  utmSource       String?   @db.VarChar(255) // e.g., "reddit", "google", "facebook"
  utmMedium       String?   @db.VarChar(255) // e.g., "cpc", "social", "email"
  utmCampaign     String?   @db.VarChar(255) // e.g., "spring_sale", "product_launch"
  utmTerm         String?   @db.VarChar(255) // e.g., "trading journal"
  utmContent      String?   @db.VarChar(255) // e.g., "banner_ad", "text_link"

  // Session metadata
  referrer        String?   @db.VarChar(2048) // Where they came from
  landingPage     String    @db.VarChar(2048) // First page they visited
  ipHash          String?   @db.VarChar(64)   // Hashed IP for privacy
  userAgent       String?   @db.Text          // Browser/device info
  country         String?   @db.VarChar(100)  // Optional: Geolocation
  city            String?   @db.VarChar(100)  // Optional: Geolocation

  // Timestamps
  firstSeenAt     DateTime  @default(now())
  lastSeenAt      DateTime  @default(now())
  createdAt       DateTime  @default(now())

  // Relations
  pageViews       AnalyticsPageView[]

  @@index([sessionId])
  @@index([userId, firstSeenAt])
  @@index([utmSource, firstSeenAt])
  @@index([utmMedium, firstSeenAt])
  @@index([utmCampaign, firstSeenAt])
  @@index([landingPage])
  @@index([firstSeenAt])
  @@map("analytics_sessions")
}

model AnalyticsPageView {
  id              String    @id @default(cuid())
  sessionId       String    // Links to AnalyticsSession.sessionId (not id)
  userId          String?   // NULL for anonymous visitors

  // Page tracking
  path            String    @db.VarChar(2048) // Full path including query params
  normalizedPath  String    @db.VarChar(2048) // Normalized path (e.g., /blog/[slug] -> /blog)
  previousPath    String?   @db.VarChar(2048) // For funnel/flow analysis

  // Duration tracking
  enteredAt       DateTime  @default(now())
  exitedAt        DateTime?
  duration        Int?      // Time spent in milliseconds

  // Metadata
  createdAt       DateTime  @default(now())

  // Relations
  session         AnalyticsSession @relation(fields: [sessionId], references: [sessionId], onDelete: Cascade)

  @@index([sessionId, enteredAt])
  @@index([userId, enteredAt])
  @@index([normalizedPath, enteredAt])
  @@index([path])
  @@index([enteredAt])
  @@index([createdAt])
  @@map("analytics_page_views")
}

model FeedbackResponse {
  id              String    @id @default(cuid())
  userId          String?   // Optional - can be anonymous
  userName        String    @db.VarChar(255)
  userEmail       String    @db.VarChar(255)
  question1Rating Int       @db.SmallInt // 1-10: How easy was it to navigate and use the application?
  question2Rating Int       @db.SmallInt // 1-10: How useful are the trading analytics and insights provided?
  question3Rating Int       @db.SmallInt // 1-10: How would you rate the quality of the data visualizations?
  question4Rating Int       @db.SmallInt // 1-10: How satisfied are you with the application's performance and speed?
  question5Rating Int       @db.SmallInt // 1-10: How likely are you to recommend Trade Voyager Analytics?
  comment         String?   @db.VarChar(5000) // Limited to 5000 chars for security
  submittedAt     DateTime  @default(now())
  token           String    @unique @db.VarChar(100)
  tokenUsed       Boolean   @default(false)
  ipAddressHash   String?   @db.VarChar(64) // Hashed IP for rate limiting
  createdAt       DateTime  @default(now())

  user            User?     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, submittedAt])
  @@index([submittedAt])
  @@index([token])
  @@index([ipAddressHash, submittedAt]) // For rate limiting queries
  @@map("feedback_responses")
}

model ContactSubmission {
  id              String    @id @default(cuid())
  name            String?
  email           String?
  message         String    @db.Text
  submittedAt     DateTime  @default(now())
  ipAddress       String?
  userAgent       String?
  isRead          Boolean   @default(false)
  readAt          DateTime?
  createdAt       DateTime  @default(now())

  @@index([submittedAt])
  @@index([isRead])
  @@map("contact_submissions")
}

model BannedUser {
  id                String    @id @default(cuid())
  email             String    @unique
  auth0Id           String?   // The auth0 ID at time of ban (may be deleted from Auth0)
  originalUserId    String    // Reference to the deleted user ID
  bannedAt          DateTime  @default(now())
  bannedBy          String    // Admin user ID who banned them
  reason            String?   @db.Text

  // Identity tracking - to prevent re-registration via any method
  identities        Json?     // Store all Auth0 identities (google, github, email, etc.)
  googleEmail       String?   // If they used Google login
  githubUsername    String?   // If they used GitHub login

  // Additional metadata
  bannedVia         BanSource @default(ADMIN_DELETE)
  userMetadata      Json?     // Store any additional user data for reference
  ipAddresses       String[]  @default([]) // IPs used by this user (optional)

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@index([email])
  @@index([auth0Id])
  @@index([googleEmail])
  @@index([githubUsername])
  @@index([bannedAt])
  @@map("banned_users")
}

enum BanSource {
  ADMIN_DELETE      // Banned via immediate admin deletion
  MANUAL_BAN        // Manually banned without deletion
  FRAUD_DETECTION   // Auto-banned by fraud detection
  POLICY_VIOLATION  // Banned for policy violation

  @@map("ban_source")
}

// ============================================================================
// BLOG MODELS - Admin-authored content with SEO optimization
// ============================================================================

model BlogPost {
  id              String         @id @default(cuid())
  slug            String         @unique @db.VarChar(255)
  title           String         @db.VarChar(255)
  excerpt         String?        @db.VarChar(500)
  content         String         @db.Text
  coverImage      String?        @db.VarChar(500)
  author          String         @db.VarChar(100)
  authorId        String
  status          BlogStatus     @default(DRAFT)
  viewCount       Int            @default(0)
  seoTitle        String?        @db.VarChar(255)
  seoDescription  String?        @db.VarChar(500)
  publishedAt     DateTime?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  authorUser      User           @relation(fields: [authorId], references: [id], onDelete: Cascade)
  tags            BlogPostTag[]

  @@index([status, publishedAt(sort: Desc)])
  @@index([slug])
  @@index([authorId])
  @@map("blog_posts")
}

model BlogTag {
  id        String        @id @default(cuid())
  name      String        @unique @db.VarChar(50)
  slug      String        @unique @db.VarChar(50)
  postCount Int           @default(0)
  createdAt DateTime      @default(now())

  posts     BlogPostTag[]

  @@index([slug])
  @@map("blog_tags")
}

model BlogPostTag {
  id        String   @id @default(cuid())
  postId    String
  tagId     String
  createdAt DateTime @default(now())

  post      BlogPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  tag       BlogTag  @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([postId, tagId])
  @@index([tagId])
  @@map("blog_post_tags")
}

enum BlogStatus {
  DRAFT
  PUBLISHED
  ARCHIVED

  @@map("blog_status")
}
